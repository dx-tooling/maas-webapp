## Orchestration and Routing (Production)

This document explains how the MCP/VNC orchestration works once the Docker-based rewrite is fully implemented in production.

### High-level architecture

- DNS
  - `app.mcp-as-a-service.com` → public IP of the production host
  - `*.mcp-as-a-service.com` (wildcard) → same public IP
- Reverse proxy (Traefik)
  - Runs as a single Docker container (Traefik v3.5) on the host
  - Listens on host ports 80/443
  - Terminates TLS for all domains/subdomains
  - Routes traffic to either the native webapp on the host or to per-instance containers
- Web application (native on host)
  - nginx + PHP-FPM serving Symfony at `http://localhost:8080`
  - No direct exposure on 80/443 (Traefik fronts all HTTP/S traffic)
- MCP/VNC instance containers (one per user instance)
  - No host ports published
  - Expose internal ports only: 8080 (MCP), 6080 (noVNC), 5900 (raw VNC internal only)
  - Connected to a shared Docker network with Traefik (e.g., `mcp_instances`)

Request flow (conceptually):

```
Internet (80/443) → Traefik (container) → {
  app.mcp-as-a-service.com  → host nginx:8080 (native Symfony app)
  mcp-<slug>.mcp-as-a-service.com → mcp-instance-<slug>:8080 (MCP)
  vnc-<slug>.mcp-as-a-service.com → mcp-instance-<slug>:6080 (noVNC)
}
```

### Networking

- Traefik and all MCP instance containers join the same Docker network: `mcp_instances`.
- Traefik reaches instance containers by their Docker DNS name on internal ports (no host port publishing).
- Traefik must reach host nginx on port 8090. Options:
  - Use `host.docker.internal` as the service URL (if supported)
  - Or run Traefik with host networking (not required, but possible)

### Routing via Docker labels

Traefik is configured with the Docker provider, so it auto-discovers containers and their routing rules from labels. The webapp creates instance containers with labels specifying:

- Routers: host-based rules per instance
- Services: which internal port to forward to
- Middlewares: ForwardAuth for MCP

Example labels generated by the app for an instance slug `abcd1234`:

```
traefik.enable=true

# MCP router and service
traefik.http.routers.mcp-abcd1234.rule=Host(`mcp-abcd1234.mcp-as-a-service.com`)
traefik.http.routers.mcp-abcd1234.entrypoints=websecure
traefik.http.services.mcp-abcd1234.loadbalancer.server.port=8080

# MCP ForwardAuth middleware
traefik.http.middlewares.mcp-abcd1234-auth.forwardauth.address=https://app.mcp-as-a-service.com/auth/mcp-bearer-check
traefik.http.routers.mcp-abcd1234.middlewares=mcp-abcd1234-auth

# VNC (noVNC) router and service
traefik.http.routers.vnc-abcd1234.rule=Host(`vnc-abcd1234.mcp-as-a-service.com`)
traefik.http.routers.vnc-abcd1234.entrypoints=websecure
traefik.http.services.vnc-abcd1234.loadbalancer.server.port=6080
```

Notes:

- Only noVNC (6080) is proxied; raw VNC (5900) remains internal.
- `websecure` entrypoint is HTTPS. TLS termination and certs are handled by Traefik.
- In production, TLS is provided by host-mounted wildcard certificates in Traefik (no ACME cert resolver on routers).

### ForwardAuth for MCP

All MCP requests are edge-protected. The router attaches a ForwardAuth middleware that calls a Symfony endpoint to validate `Authorization: Bearer <token>`.

- Endpoint: `GET /auth/mcp-bearer-check`
- Identity: instance slug parsed from the `Host` header (`mcp-<slug>.mcp-as-a-service.com`)
- Verification: compares presented bearer token to the instance’s `mcpBearer` secret stored in DB
- Cache: 5‑minute in-memory cache for the token per instance
- Responses:
  - 204 → allow
  - 401/403 → deny

### Instance lifecycle (managed by the webapp)

Create instance:
1. Create `McpInstance` entity with defaults (screen dims) and generated `vncPassword` + `mcpBearer`.
2. Persist and flush to obtain UUID.
3. Derive fields: `instanceSlug`, `containerName`, `mcpSubdomain`, `vncSubdomain`.
4. Create Docker container via CLI with env vars and Traefik labels; join `mcp_instances` network.
5. Start the container; set state to `running`.

Restart/remove:
- Restart calls Docker restart; state updated accordingly.
- Stop & remove stops the container and deletes the entity.

Health checks:
- Container has a healthcheck for MCP (8080).
- App-level health considers MCP 8080 and noVNC 6080 reachable via `docker exec curl`.

### Security model

- MCP: Authorization enforced at edge via ForwardAuth; secret stored per instance (`mcpBearer`).
- VNC: Protected by the container’s VNC password; only noVNC proxied over HTTPS.
- TLS: Handled by Traefik (wildcard certificate for `*.mcp-as-a-service.com` and main domain).
- Logging: Minimal, no sensitive token values logged; rate-limit failed auths (planned).

### Operational setup (production)

Prerequisites:
- DNS: `app.mcp-as-a-service.com` and wildcard `*.mcp-as-a-service.com` → host IP
- Docker network: `docker network create mcp_instances`
- Permissions: User `www-data` does not need to be added to the system's `docker` group - instead, a sudoers entry exists (see docs/infrastructure/etc/sudoers.d/101-www-data-docker-cli-wrapper) which enables User www-data to run script bin/docker-cli-wrapper with superuser privileges
- nginx: listen on localhost port 8080 only (no TLS, Traefik terminates)
- Traefik: container exposing 80/443; configured Docker provider; uses wildcard TLS

Resource limits:
- Instance containers started with, e.g., `--memory=1g` and `--restart=always`.

Backups and persistence:
- MCP instance containers are stateless; DB is the source of truth.

### Local development differences

- `docker-compose.yml` provides Traefik and a sample instance using `*.localhost` host rules.
- Certs: dev uses self-signed/`insecureSkipVerify`; production uses real wildcard TLS.
- The Symfony app can still run natively in dev, but for local E2E testing the example container demonstrates routing.


