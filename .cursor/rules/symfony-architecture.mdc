# Symfony 7.3 Core Architecture & Coding Rules

## General Principles
- Write concise, technical code with accurate PHP examples.
- Use object-oriented programming and SOLID principles.
- Prefer iteration and modularization over duplication.
- Use descriptive variable and method names, even if long.
- Favor dependency injection and service containers.
- Prefer TypeScript over JavaScript, and use TypeScript's type system extensively.

## Feature/Layer Structure & Isolation (Hard Rule)
- Every feature lives in its own top-level namespace under `App\FeatureName`.
- Allowed layers (per feature):
  - **Domain**: Pure business logic. May access DB (including raw SQL) for own tables. May reference own Infrastructure and TestHarness. No Presentation/Api references. No cross-feature dependencies (not even DB-level foreign keys).
  - **Presentation**: UI (web pages, emails, etc.). Controllers, view models, templates. No business logic. May use own Domain, Infrastructure, or TestHarness. **NO direct access to own Facade** - Facades are external interfaces only.
  - **Api**: Programmatic interfaces (REST, GraphQL, etc.). API controllers, serializers, DTOs. May use own Domain, Infrastructure, or TestHarness. **NO direct access to own Facade** - Facades are external interfaces only.
  - **Infrastructure**: External APIs, filesystem, low-level services. May be referenced by any layer in the same feature. No direct access to other features.
  - **TestHarness**: Test utilities, mocks, simulation tools for both automated testing and developer productivity (e.g., fake data generators). May be referenced by any layer in the same feature. Not for production use.
- No cross-feature references except via Facade Interfaces. Every feature must provide a Facade Interface for this purpose.
- No DB-level foreign keys between tables of different features.
- Each feature must be testable in isolation, using interface-based mocks for dependencies on other features.
- **Facades are EXTERNAL interfaces only - components within the same feature must use Domain services directly, not their own Facade.**

## Date and Time (Hard Rule)
- **Never instantiate `DateTimeImmutable`, `DateTime`, or similar directly.**
- **Always use the `DateAndTimeService` for all time-related operations.**
- Applies to all layers. No exceptions. Violations break testability.
- Example:
  ```php
  // ✅ Correct
  $now = $this->dateAndTimeService->getDateTimeImmutable();

  // ❌ Incorrect
  $now = new \DateTimeImmutable();
  $now = new \DateTime();
  ```

## Facade Pattern Usage (Hard Rule)
- **Facades are EXTERNAL interfaces for other features, NOT internal services within the same feature.**
- **What Facades Are For:**
  - External Integration: Facades provide a clean, stable interface for other features to interact with your feature
  - API Contracts: They define the public contract that other parts of the system can rely on
  - Abstraction: They hide internal implementation details and provide a simplified interface
- **What Facades Are NOT For:**
  - Internal Services: Components within the same feature should NOT use the facade
  - Internal Communication: Use domain services, application services, or repositories for internal operations
  - Data Access: Controllers and components should directly use the appropriate service layer
- **Implementation Rules:**
  - Controllers and Components: Use domain services directly, not facades
  - Facade Methods: Should only delegate to domain services, not contain business logic
  - Service Dependencies: Inject domain services into presentation layer components
  - External Access: Other features use facades to access your feature's functionality

## Type System & DTOs (Hard Rule)
- Use the PHP type system extensively. Avoid untyped or mixed values, parameters, return values, etc.
- **No complex, multi-level associative arrays.**
  - Arrays are only allowed as:
    - Non-associative lists of values (e.g., `list<string>`, `list<UserDto>`), all values same type - and not `string[]` or `UserDto[]`.
    - Simple, one-dimensional key-value pairs, but only in very local contexts (e.g., passing between two methods in the same class, where a DTO would be overkill).
  - **Associative arrays must never be used as pseudo-objects or data structures that cross class or feature boundaries.**
  - All structured data passed between classes, layers, or features must use proper DTOs or value objects.
  - **Classes shall never emit associative arrays, especially not multi-dimensional ones, unless it's in a very local context (e.g. private method in a class).**
- Example:
  ```php
  // ✅ Correct: List of DTOs
  /** @var UserDto[] $users */
  $users = [$user1, $user2];

  // ✅ Correct: Simple local key-value array
  $options = ['foo' => 'bar', 'baz' => 'qux'];

  // ❌ Incorrect: Multi-level associative array as a pseudo-object
  $data = [
      'user' => [
          'name' => 'Alice',
          'address' => [
              'city' => 'Berlin'
          ]
      ]
  ]; // Use DTOs instead!
  ```

## Cross-Layer Dependencies (Hard Rule)
- **Elements from layer A can reference and use elements from layer B, as long as they are either interfaces or values (enums, DTOs, but not entities).**
- **Everything that can be easily mocked (interfaces) or does not need to be mocked (DTOs, Enums) can be used from other layers.**
- **Example: Presentation layer can directly use interfaces, DTOs and enums from Domain, and doesn't need to replicate them, if these happen to serve the interests of Presentation anyway.**
- **For everything else, Presentation can still create its own elements and translate/transpose accordingly.**
- **Domain entities should never be exposed to Presentation layer - use DTOs instead.**
- Example:
  ```php
  // ✅ Correct: Presentation using Domain interfaces and DTOs
  class PresentationService {
      public function __construct(
          private DomainServiceInterface $domainService, // Interface from Domain
          private SomeEnum $enum, // Enum from Domain
      ) {}

      public function getData(): PresentationDto {
          $domainDto = $this->domainService->getData(); // DTO from Domain
          return $this->mapToPresentation($domainDto);
      }
  }

  // ❌ Incorrect: Presentation using Domain entities
  class PresentationService {
      public function __construct(
          private DomainEntity $entity, // Entity from Domain - NOT ALLOWED
      ) {}
  }
  ```

## PHP/Symfony Best Practices
- Use PHP 8.4 features and strict typing: `declare(strict_types=1);`
- Use PHP Attributes for entities, not Annotations.
- Never use named arguments when calling functions/methods.
- Use Symfony’s built-in features and helpers when possible.
- Implement proper error handling and logging (Symfony’s features, custom exceptions, try-catch for expected exceptions).
- Use Symfony’s validation for forms/requests.
- Use Symfony’s event/subscriber system for decoupling where sensible.
- Use Composer for dependency management.
- Always consider strings as multibyte UTF-8, use `mb_` functions as needed.

## Doctrine/Database
- Never write or modify Doctrine migrations yourself—only create correct entity classes (using PHP Attributes). Ask the developer to have them created and applied when needed.
- Prefer raw SQL for complex queries, but never hardcode table names (use `$this->entityManager->getClassMetadata(SomeEntity::class)->getTableName()`).
- For simple cases, use Doctrine EntityManager methods (`find()`, `findOneBy()`, etc.).
- If EM-managed entities are available, prefer using them over raw SQL for simple cases.

## Code Quality Enforcement (Hard Rule)
- All code must pass PHPStan at the highest level (level 9), as configured in [`phpstan.dist.neon`](mdc:phpstan.dist.neon).
- All code must pass all configured quality tools (PHP CS Fixer, ESLint, Prettier, etc.).
- **No commits or merges to `main` are allowed if there are any open issues reported by these tools.**

---

For any questions or clarifications, see the referenced config files or ask the project maintainer.
description:
globs:
alwaysApply: true
---
